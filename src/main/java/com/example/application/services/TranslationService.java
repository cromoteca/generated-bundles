package com.example.application.services;

import com.vaadin.flow.server.auth.AnonymousAllowed;
import com.ibm.icu.text.MessagePattern;
import dev.hilla.BrowserCallable;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

@BrowserCallable
@AnonymousAllowed
public class TranslationService {

    public void generateTranslations() {
        var bundle = ResourceBundle.getBundle("com.example.application.messages.Messages", Locale.getDefault());
        var analysisResults = new LinkedHashMap<String, Map<String, String>>();
        var keys = bundle.getKeys();

        // build a map of message keys and their parameter details
        while (keys.hasMoreElements()) {
            var key = keys.nextElement();
            var message = bundle.getString(key);
            var parameterDetails = extractParameterDetails(message);
            analysisResults.put(key, parameterDetails);
        }

        // generate some example TypeScript code and print it to the console
        var code = generateTypeScriptCode(analysisResults);
        System.out.println(code);
    }

    private static String generateTypeScriptCode(Map<String, Map<String, String>> analysisResults) {
        var codeBuilder = new StringBuilder();

        for (var entry : analysisResults.entrySet()) {
            var key = entry.getKey();
            var methodName = convertKeyToMethodName(key);
            var parameterDetails = entry.getValue();

            codeBuilder.append("export function ").append(methodName).append("(");

            for (var parameterEntry : parameterDetails.entrySet()) {
                var parameterName = parameterEntry.getKey();
                var parameterType = parameterEntry.getValue();
                codeBuilder.append(parameterName).append(": ").append(parameterType).append(", ");
            }

            if (!parameterDetails.isEmpty()) {
                codeBuilder.setLength(codeBuilder.length() - 2);
            }

            codeBuilder.append("): string { return translate('").append(key).append("'");

            for (var parameterName : parameterDetails.keySet()) {
                codeBuilder.append(", ").append(parameterName);
            }

            codeBuilder.append("); }\n");
        }

        return codeBuilder.toString();
    }

    private static Map<String, String> extractParameterDetails(String message) {
        var details = new LinkedHashMap<String, String>();
        var pattern = new MessagePattern(message);
        var partCount = pattern.countParts();

        for (int i = 0; i < partCount; i++) {
            var part = pattern.getPart(i);

            // if the part is an argument start, it can be a parameter
            // it depends on the next part
            if (part.getType() == MessagePattern.Part.Type.ARG_START) {
                var nameType = pattern.getPartType(i + 1);
                var name = pattern.getSubstring(pattern.getPart(i + 1));

                // if the name is a number, it's an unnamed parameter
                if (nameType == MessagePattern.Part.Type.ARG_NUMBER) {
                    name = "arg" + name;
                }
                // if the name is neither a number not a name, it's not a parameter
                else if (nameType != MessagePattern.Part.Type.ARG_NAME) {
                    continue;
                }

                // the type of the parameter depends on the next part
                var typeType = pattern.getPartType(i + 2);
                var type = "string";

                if (typeType == MessagePattern.Part.Type.ARG_TYPE) {
                    var declaredType = pattern.getSubstring(pattern.getPart(i + 2));

                    if ("number".equals(declaredType)) {
                        type = "number";
                    } else if ("date".equals(declaredType)) {
                        // not dealing with the date format, so allow a string also
                        type = "Date | string";
                    }
                } else if (typeType == MessagePattern.Part.Type.ARG_SELECTOR) {
                    // selectors are always numbers
                    type = "number";
                }

                details.put(name, type);
            }
        }

        return details;
    }

    // convert a message key to a method name
    // code generated by ChatGPT, can be replaced with something from an existing library
    private static String convertKeyToMethodName(String key) {
        var parts = key.split("[._]");
        var methodNameBuilder = new StringBuilder(parts[0].toLowerCase());

        for (var i = 1; i < parts.length; i++) {
            methodNameBuilder
                    .append(parts[i].substring(0, 1).toUpperCase())
                    .append(parts[i].substring(1).toLowerCase());
        }

        return methodNameBuilder.toString();
    }
}
